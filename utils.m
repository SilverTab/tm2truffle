#import "utils.h"
#import <self-ml/SFONode.h>


#pragma mark -
#pragma mark Metadata
int importMetaData(NSString *bundleRoot, NSString *outputFile)
{
	NSFileManager *fm = [NSFileManager defaultManager];
	NSString *metaDataPath = [bundleRoot stringByAppendingPathComponent:@"info.plist"];
	NSString *metaDataOutputPath = [outputFile stringByAppendingPathComponent:@"truffle.selfml"];
	if (![fm fileExistsAtPath:metaDataPath]) {
		NSLog(@"This is not normal...No info.plist, can't import! DUCK AND COVER!");
		return 0;
	}
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaDic = [NSDictionary dictionaryWithContentsOfFile:metaDataPath];
	
	// provider...
	NSString *provider;
	if([metaDic objectForKey:@"contactName"] != nil) {
		provider = [@"private." stringByAppendingString:[[[metaDic objectForKey:@"contactName"] lowercaseString] stringByReplacingOccurrencesOfString:@" " withString:@"-"]];
	} else {
		provider = @"private.anonymous";
	}
	SFONode *providerNode = SELFML(@"provider", provider);
	[rootNode addChild:providerNode];
	
	// name
	if([metaDic objectForKey:@"contactName"] != nil) {
		SFONode *nameNode = SELFML(@"author", [metaDic objectForKey:@"contactName"]);
		[rootNode addChild:nameNode];
	}
	
	
	// email
	if([metaDic objectForKey:@"contactEmailRot13"] != nil) {
		SFONode *emailNode = SELFML(@"rot-13-email", [metaDic objectForKey:@"contactEmailRot13"]);
		[rootNode addChild:emailNode];
	}
	
	[[@"### Generated by tm2truffle\n\n" stringByAppendingString:[rootNode selfmlRepresentation]] writeToFile:metaDataOutputPath 
																								   atomically:YES 
																									 encoding:NSUTF8StringEncoding 
																										error:nil];
	
	//NSLog(@"Meta info: %@", [rootNode selfmlRepresentation]);
	
	return 1;
}

#pragma mark -
#pragma mark Useful stuff
int createOutputDir(NSString *outputFile) 
{
	NSError *error;
	[[NSFileManager defaultManager] createDirectoryAtPath:outputFile 
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:&error];
	if(error) {
		NSLog(@"%@", [error localizedDescription]);
		return 0;
	}
	
	return 1;
}


#pragma mark Snippets 

void processSnippet(NSString *snippetPath)
{
	NSDictionary *snippetAsDic = [NSDictionary dictionaryWithContentsOfFile:snippetPath];
	NSLog(@"%@", [snippetAsDic valueForKey:@"name"]);
}

void importSnippets(NSString *bundleRoot, NSString *outputFile)
{
	NSString *snippetsPath = [bundleRoot stringByAppendingPathComponent:@"Snippets"];
	NSMutableArray *snippets = [[NSMutableArray alloc] init];
	if(![[NSFileManager defaultManager] fileExistsAtPath:snippetsPath]) {
		NSLog(@"No snippets to import...continuing...");
		return;
	}
	// create the snippet directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputFile stringByAppendingPathComponent:@"snippets"]
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *snippet in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:snippetsPath error:nil]) {
		if([[[snippet pathExtension] lowercaseString] isEqual:@"tmsnippet"] || [[[snippet pathExtension] lowercaseString] isEqual:@"plist"]) {
			[snippets addObject:snippet];
		}
	}
	
	for(NSString *snippet in snippets) {
		processSnippet([snippetsPath stringByAppendingPathComponent:snippet]);
	}
	
}

#pragma mark -
#pragma mark Commands

void processCommand(NSString *fullPath, NSString *outputPath)
{
	NSString *fileName = [[[fullPath lastPathComponent] lowercaseString] stringByReplacingOccurrencesOfString:@" " withString:@"-"];
	NSString *fullFileName = [fileName stringByReplacingOccurrencesOfString:[fileName pathExtension] withString:@"selfml"];
	NSDictionary *commandDic = [NSDictionary dictionaryWithContentsOfFile:fullPath];
	NSString *fullOutputPath = [outputPath stringByAppendingPathComponent:fullFileName];
	SFONode *rootNode = [SFONode node];
	
	// output equivalent dic
	NSMutableDictionary *outputDic = [[NSMutableDictionary alloc] init];
	[outputDic setObject:@"nothing" forKey:@"discard"];
	[outputDic setObject:@"replace-selected" forKey:@"replaceSelectedText"];
	[outputDic setObject:@"replace-all" forKey:@"replaceDocument"];
	[outputDic setObject:@"after-selected" forKey:@"afterSelectedText"];
	[outputDic setObject:@"snippet" forKey:@"insertAsSnippet"];
	[outputDic setObject:@"html" forKey:@"showAsHTML"];
	[outputDic setObject:@"tooltip" forKey:@"showAsTooltip"];
	[outputDic setObject:@"new-document" forKey:@"openAsNewDocument"];
	
	// beforeRunningCommand dic
	NSMutableDictionary *brcDic = [[NSMutableDictionary alloc] init];
	[brcDic setObject:@"nothing" forKey:@"nop"];
	[brcDic setObject:@"file" forKey:@"saveActiveFile"];
	[brcDic setObject:@"project" forKey:@"saveModifiedFiles"];
	
	// name
	if([commandDic objectForKey:@"name"] != nil) {
		SFONode *nameNode = SELFML(@"name", [commandDic objectForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	
	// scope
	if([commandDic objectForKey:@"scope"] != nil) {
		SFONode *scopeNode = SELFML(@"only-in", [commandDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// input
	if ([commandDic objectForKey:@"input"] != nil) {
		NSString *inputValue = ([[commandDic objectForKey:@"input"] isEqual:@"none"]) ? @"nothing" : [commandDic objectForKey:@"input"];
		SFONode *inputNode = SELFML(@"input", inputValue);
		
		if ([commandDic objectForKey:@"fallbackInput"] != nil) {
			[inputNode addChild:(NSString *)[commandDic objectForKey:@"fallbackInput"]];
		}
		
		[rootNode addChild:inputNode];
	}
	
	// output
	if([commandDic objectForKey:@"output"] != nil) {
		NSString *outputValue = [outputDic objectForKey:[commandDic objectForKey:@"output"]];
		SFONode *outputNode = SELFML(@"output", outputValue);
		[rootNode addChild:outputNode];
	}
	
	// brc
	if([commandDic objectForKey:@"beforeRunningCommand"] != nil) {
		SFONode *brcNode = SELFML(@"save", [brcDic objectForKey:[commandDic objectForKey:@"beforeRunningCommand"]]);
		[rootNode addChild:brcNode];
	}
	
	// src
	if([commandDic objectForKey:@"command"] != nil) {
		SFONode *commandNode = SELFML(@"script", [commandDic objectForKey:@"command"]);
		[rootNode addChild:commandNode];
	}
	
	[[rootNode selfmlRepresentation] writeToFile:fullOutputPath 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
}

void importCommands(NSString *bundleRoot, NSString *outputFile)
{
	NSString *commandsPath = [bundleRoot stringByAppendingPathComponent:@"Commands"];
	NSString *commandsOutputPath = [outputFile stringByAppendingPathComponent:@"commands"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	if(![[NSFileManager defaultManager] fileExistsAtPath:commandsPath]) {
		NSLog(@"No commnads to import...continuing...");
		return;
	}
	// create the snippet directory...
	[fm createDirectoryAtPath:commandsOutputPath
  withIntermediateDirectories:YES 
				   attributes:nil 
						error:nil];
	
	for(NSString *command in [fm contentsOfDirectoryAtPath:commandsPath error:nil]) {
		if([[[command pathExtension] lowercaseString] isEqual:@"tmcommand"] || [[[command pathExtension] lowercaseString] isEqual:@"plist"]) {
			processCommand([commandsPath stringByAppendingPathComponent:command], commandsOutputPath);
		}
	}
	
}


#pragma mark -
#pragma mark Language/Syntax

void processPattern(NSDictionary *pattern, SFONode **rootNode) {
	SFONode *nodePattern;
	
	// Deal with includes right alway
	if([pattern objectForKey:@"include"] != nil) {
		nodePattern = SELFML(@"include", [[pattern objectForKey:@"include"] stringByReplacingOccurrencesOfString:@"#" withString:@"@"]);
		[*rootNode addChild:nodePattern];
		return;
	}
	

	if([pattern objectForKey:@"name"] != nil) {
		nodePattern = SELFML(@"zone", [pattern objectForKey:@"name"]);
	} else {
		nodePattern = SELFML(@"zone");
		if([pattern objectForKey:@"contentName"] != nil) {
			SFONode *innerIdentifier = SELFML(@"innerIdentifier", [pattern objectForKey:@"contentName"]);
			[nodePattern addChild:innerIdentifier];
		}
	}

	
	// match
	if([pattern objectForKey:@"match"] != nil) {
		SFONode *regexNode = SELFML(@"regex", [pattern objectForKey:@"match"]);
		SFONode *matchNode = SELFML(@"match");
		[matchNode addChild:regexNode];
		
		if([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *captureDic = [pattern objectForKey:@"captures"];
			
			if([captureDic objectForKey:@"contentName"] != nil){
				[matchNode addChild:(NSString *)[captureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [captureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[captureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		[nodePattern addChild:matchNode];
	}
	if([pattern objectForKey:@"begin"] != nil) {
		SFONode *regexNode = SELFML(@"regex", [pattern objectForKey:@"begin"]);
		SFONode *startNode = SELFML(@"start");
		// come up with the name
		
		[startNode addChild:regexNode];
		
		if([pattern objectForKey:@"beginCaptures"] != nil) {
			NSDictionary *beginCaptureDic = [pattern objectForKey:@"beginCaptures"];
			
			if([beginCaptureDic objectForKey:@"contentName"] != nil){
				[startNode addChild:(NSString *)[beginCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [beginCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[beginCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		[nodePattern addChild:startNode];
	}
	if([pattern objectForKey:@"end"] != nil) {
		SFONode *regexNode = SELFML(@"regex", [pattern objectForKey:@"end"]);
		SFONode *endNode = SELFML(@"end");
		[endNode addChild:regexNode];
		
		if([pattern objectForKey:@"endCaptures"] != nil) {
			NSDictionary *endCaptureDic = [pattern objectForKey:@"endCaptures"];
			
			if([endCaptureDic objectForKey:@"contentName"] != nil){
				[endNode addChild:(NSString *)[endCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [endCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[endCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		
		[nodePattern addChild:endNode];
	}
	
	// Deal with inner patterns...reccursively?
	if([pattern objectForKey:@"patterns"] != nil) {
		SFONode *subzoneNode = SELFML(@"subzones");
		for(NSDictionary *subpattern in [pattern valueForKey:@"patterns"]) {
			processPattern(subpattern, &subzoneNode);
		}
		[nodePattern addChild:subzoneNode];
	}
	
	//NSLog(@"Zone: %@", [nodePattern selfmlRepresentation]);
	[*rootNode addChild:nodePattern];
}

void processLanguage(NSString *languagePath, NSString *outputPath)
{
	NSDictionary *languageAsDic = [NSDictionary dictionaryWithContentsOfFile:languagePath];
	
	NSString *bundleSourceName = [languageAsDic valueForKey:@"scopeName"];
	NSMutableArray *components = [[bundleSourceName componentsSeparatedByString:@"."] mutableCopy];
	[components removeObject:@"source"];
	[components removeObject:@"sourcecode"];
	NSString *outputDirName = [[components componentsJoinedByString:@"."] stringByReplacingOccurrencesOfString:@"/" withString:@""];
	
	// Create the output directory
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputPath stringByAppendingPathComponent:outputDirName]
							  withIntermediateDirectories:NO 
											   attributes:nil 
													error:nil];
	
	SFONode *rootNode = SELFML(@"root", [languageAsDic valueForKey:@"scopeName"]);
	
	// patterns...
	for(NSDictionary *pattern in [languageAsDic valueForKey:@"patterns"])
	{
		processPattern(pattern, &rootNode);
	}
	
	[[rootNode selfmlRepresentation] writeToFile:[[outputPath stringByAppendingPathComponent:outputDirName] stringByAppendingPathComponent:@"syntax.selfml"] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
	
	//NSLog(@"Out: %@", [rootNode selfmlRepresentation]);
}

void importLanguages(NSString *bundleRoot, NSString *outputFile)
{
	NSString *syntaxInPath = [bundleRoot stringByAppendingPathComponent:@"Syntaxes"];
	NSString *syntaxOutPath = [outputFile stringByAppendingPathComponent:@"languages"];

	
	// create the languages directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:syntaxOutPath
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *language in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:syntaxInPath error:nil]) {
		if([[[language pathExtension] lowercaseString] isEqual:@"tmlanguage"] || [[[language pathExtension] lowercaseString] isEqual:@"plist"]) {
			processLanguage([syntaxInPath stringByAppendingPathComponent:language], syntaxOutPath);
		}
	}
	
}

#pragma mark -
#pragma mark Resources

void copyResources(NSString *bundleRoot, NSString *outputFile)
{
	NSString *supportDir = [bundleRoot stringByAppendingPathComponent:@"Support"];
	NSString *destinationPath = [outputFile stringByAppendingPathComponent:@"resources"];
	
	if(![[NSFileManager defaultManager] fileExistsAtPath:supportDir]) 
		return;
	

	[[NSFileManager defaultManager] copyItemAtPath:supportDir toPath:destinationPath error:nil];
	
	
}

#pragma mark -
#pragma mark Templates
void processTemplate(NSString *fullPath, NSString *outputDir, NSString *bundleRoot)
{
	// OK so, the info.plist contains the meta data about the template,
	// every other file in there is an actual template!
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaData = [NSDictionary dictionaryWithContentsOfFile:[fullPath stringByAppendingPathComponent:@"info.plist"]];
	NSDictionary *bundleMetaData = [NSDictionary dictionaryWithContentsOfFile:[bundleRoot stringByAppendingPathComponent:@"info.plist"]];
	// first the name!
	if([metaData objectForKey:@"name"]) {
		SFONode *nameNode = SELFML(@"name", [metaData valueForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	// Group
	SFONode *platformNode = SELFML(@"group.platform", @"Misc");
	[rootNode addChild:platformNode];
	
	// Get the name of the bundle...
	SFONode *principleNode;
	if([bundleMetaData objectForKey:@"name"] != nil) {
		principleNode = SELFML(@"group.principles", [bundleMetaData objectForKey:@"name"]);
	} else {
		principleNode = SELFML(@"group.principles", @"Unknown");
	}
	[rootNode addChild:principleNode];
	
	NSLog(@"Template: %@", [rootNode selfmlRepresentation]);
}

void importTemplates(NSString *bundleRoot, NSString *outputFile)
{
	NSString *templatePath = [bundleRoot stringByAppendingPathComponent:@"Templates"];
	NSString *templateOutputDir = [outputFile stringByAppendingPathComponent:@"templates"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	// do we have to import them?
	if(![fm fileExistsAtPath:templatePath]) {
		NSLog(@"No templates, continuing!");
		return;
	}
	
	// Get the full path and process it!
	for(NSString *templateDir in [fm contentsOfDirectoryAtPath:templatePath error:nil]) {
		processTemplate([templatePath stringByAppendingPathComponent:templateDir], templateOutputDir, bundleRoot);
	}
	
}



