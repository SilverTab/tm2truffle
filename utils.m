#import "utils.h"
#import "SFONode.h"
#import "RegexKitLite.h"
#import "T2TSnippetConverterShared.h"
#import "T2TSnippetConverterLexer.h"

#pragma mark -
#pragma mark Metadata
int importMetaData(NSString *bundleRoot, NSString *outputFile)
{
	NSFileManager *fm = [NSFileManager defaultManager];
	NSString *metaDataPath = [bundleRoot stringByAppendingPathComponent:@"info.plist"];
	NSString *metaDataOutputPath = [outputFile stringByAppendingPathComponent:@"truffle.selfml"];
	if (![fm fileExistsAtPath:metaDataPath]) {
		NSLog(@"This is not normal...No info.plist, can't import! DUCK AND COVER!");
		return 0;
	}
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:metaDataPath] options:0 format:nil error:nil];
	
	// provider...
	NSString *provider;
	if([metaDic objectForKey:@"contactName"] != nil) {
		provider = [@"private." stringByAppendingString:[[[metaDic objectForKey:@"contactName"] lowercaseString] stringByReplacingOccurrencesOfString:@" " withString:@"-"]];
	} else {
		provider = @"private.anonymous";
	}
	SFONode *providerNode = SELFML(@"provider", provider);
	[rootNode addChild:providerNode];
	
	// name
	if([metaDic objectForKey:@"contactName"] != nil) {
		SFONode *nameNode = SELFML(@"author", [metaDic objectForKey:@"contactName"]);
		[rootNode addChild:nameNode];
	}
	
	
	// email
	if([metaDic objectForKey:@"contactEmailRot13"] != nil) {
		SFONode *emailNode = SELFML(@"rot-13-email", [metaDic objectForKey:@"contactEmailRot13"]);
		[rootNode addChild:emailNode];
	}
	
	[[@"### Generated by tm2truffle\n\n" stringByAppendingString:[rootNode selfmlRepresentation]] writeToFile:metaDataOutputPath 
																								   atomically:YES 
																									 encoding:NSUTF8StringEncoding 
																										error:nil];
	
	//NSLog(@"Meta info: %@", [rootNode selfmlRepresentation]);
	
	return 1;
}

#pragma mark -
#pragma mark Useful stuff
int createOutputDir(NSString *outputFile) 
{
	BOOL isDir;
	if(! [[NSFileManager defaultManager] fileExistsAtPath:outputFile isDirectory:&isDir] || !isDir) {
		NSError *error = nil;
		[[NSFileManager defaultManager] createDirectoryAtPath:outputFile 
								  withIntermediateDirectories:YES 
												   attributes:nil 
														error:&error];
		if(error) {
			NSLog(@"%@", [error localizedDescription]);
			return 0;
		}
		
		
	}
	return 1;
}

NSMutableArray* loadPreferences(NSString *bundleRoot) {
	NSMutableArray *prefArray = [[NSMutableArray alloc] init];
	NSString *prefPath = [bundleRoot stringByAppendingPathComponent:@"Preferences"];
	for(NSString *prefFile in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:prefPath error:nil]) {
		NSDictionary *prefDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[prefPath stringByAppendingPathComponent:prefFile]] 
																		  options:0 
																		   format:nil 
																			error:nil];
		[prefArray addObject:prefDic];
	}
	
	//NSLog(@"Prefs: %@", prefArray);
	return prefArray;
	
}

SFONode *processRegex(NSString *regex, SFONode **parentNode)
{
	NSString *stringRegex = @"^(\\(\\?i\\))?(\\^)?(\\\\b)?([^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+)(\\\\b)?(\\$)?$";
	
	if([regex rangeOfRegex:stringRegex].location != NSNotFound) {
		NSArray *matches = [regex arrayOfCaptureComponentsMatchedByRegex:stringRegex];
		[*parentNode addChild:[[matches lastObject] objectAtIndex:4]];
		// process its flags
		if([[[matches lastObject] objectAtIndex:1] length]) {
			// ignore case
			SFONode *ignoreCaseNode = SELFML(@"ignore-case");
			[*parentNode addChild:ignoreCaseNode];
		}
		if([[[matches lastObject] objectAtIndex:2] length] > 0 && [[[matches lastObject] objectAtIndex:6] length] > 0) {
			// anchor both
			SFONode *abothCaseNode = SELFML(@"anchor.both");
			[*parentNode addChild:abothCaseNode];
		} else if([[[matches lastObject] objectAtIndex:2] length] > 0) {
			// anchor left
			SFONode *aleftCaseNode = SELFML(@"anchor.left");
			[*parentNode addChild:aleftCaseNode];
		}else if([[[matches lastObject] objectAtIndex:6] length] > 0) {
			// anchor right
			SFONode *arightCaseNode = SELFML(@"anchor.right");
			[*parentNode addChild:arightCaseNode];
		}
		
		if([[[matches lastObject] objectAtIndex:3] length] > 0 && [[[matches lastObject] objectAtIndex:5] length] > 0) {
			// boundary both
			SFONode *bbothCaseNode = SELFML(@"boundary.both");
			[*parentNode addChild:bbothCaseNode];
		} else if([[[matches lastObject] objectAtIndex:3] length] > 0) {
			// boundary left
			SFONode *bleftCaseNode = SELFML(@"boundary.left");
			[*parentNode addChild:bleftCaseNode];
		}else if([[[matches lastObject] objectAtIndex:5] length] > 0) {
			// boundary right
			SFONode *brightCaseNode = SELFML(@"boundary.right");
			[*parentNode addChild:brightCaseNode];
		}
		
		return nil;
		//NSLog(@"IT'S A STRING: %@\nMatches: %@", regex, matches);
	}
	
	NSString *listRegex = @"^(\\(\\?i\\))?(\\^)?(\\\\b)?(\\([^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+(\\|[^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+)*\\))(\\\\b)?(\\$)?$";
	if([regex rangeOfRegex:listRegex].location != NSNotFound) {
		NSLog(@" IT'S A LIST: %@", regex);
		SFONode *listNode = SELFML(@"list");
		NSArray *matches = [regex arrayOfCaptureComponentsMatchedByRegex:listRegex];
		
		// list items
		NSString *contentWithoutParen = [[[matches lastObject] objectAtIndex:4] substringWithRange:NSMakeRange(1, [[[matches lastObject] objectAtIndex:4] length] -2)];
		for(NSString *item in [contentWithoutParen componentsSeparatedByString:@"|"]) {
			[listNode addChild:item];
		}
		
		[*parentNode addChild:listNode];
		
		// process its flags
		if([[[matches lastObject] objectAtIndex:1] length]) {
			// ignore case
			SFONode *ignoreCaseNode = SELFML(@"ignore-case");
			[*parentNode addChild:ignoreCaseNode];
		}
		
		if([[[matches lastObject] objectAtIndex:2] length] > 0 && [[[matches lastObject] objectAtIndex:7] length] > 0) {
			// anchor both
			SFONode *abothCaseNode = SELFML(@"anchor.both");
			[*parentNode addChild:abothCaseNode];
		} else if([[[matches lastObject] objectAtIndex:2] length] > 0) {
			// anchor left
			SFONode *aleftCaseNode = SELFML(@"anchor.left");
			[*parentNode addChild:aleftCaseNode];
		}else if([[[matches lastObject] objectAtIndex:7] length] > 0) {
			// anchor right
			SFONode *arightCaseNode = SELFML(@"anchor.right");
			[*parentNode addChild:arightCaseNode];
		}
		
		if([[[matches lastObject] objectAtIndex:3] length] > 0 && [[[matches lastObject] objectAtIndex:6] length] > 0) {
			// boundary both
			SFONode *bbothCaseNode = SELFML(@"boundary.both");
			[*parentNode addChild:bbothCaseNode];
		} else if([[[matches lastObject] objectAtIndex:3] length] > 0) {
			// boundary left
			SFONode *bleftCaseNode = SELFML(@"boundary.left");
			[*parentNode addChild:bleftCaseNode];
		}else if([[[matches lastObject] objectAtIndex:6] length] > 0) {
			// boundary right
			SFONode *brightCaseNode = SELFML(@"boundary.right");
			[*parentNode addChild:brightCaseNode];
		}
		
		
		
		return nil;
	}
	
	
	
	SFONode *regexNode = SELFML(@"regex", regex);
	[*parentNode addChild:regexNode];
	return regexNode;
}


#pragma mark -
#pragma mark Booya
void processIq(NSString *bundleRoot, NSString *outputDir, NSString *rootScope, NSDictionary *languageDict)
{
	NSArray *prefArray = loadPreferences(bundleRoot);
	SFONode *rootNode = [SFONode node];
	
#pragma mark Detectors
	if ([languageDict objectForKey:@"fileTypes"] != nil) {
		SFONode *extDetectorNode = SELFML(@"detector");
		for(NSString *ext in [languageDict objectForKey:@"fileTypes"]) {
			SFONode *anExtNode = SELFML(@"extension", ext);
			[extDetectorNode addChild:anExtNode];
		}
		[rootNode addChild:extDetectorNode];
	}
	
	if ([languageDict objectForKey:@"firstLineMatch"] != nil) {
		SFONode *contentMatchDetectorNode = SELFML(@"detector");
		SFONode *regexContentMatchNode = SELFML(@"content-matches", [languageDict objectForKey:@"firstLineMatch"]);
		[contentMatchDetectorNode addChild:regexContentMatchNode];
		[rootNode addChild:contentMatchDetectorNode];
	}
	
#pragma mark Folding
	if([languageDict objectForKey:@"foldingStartMarker"] != nil || [languageDict objectForKey:@"foldingStopMarker"]) {
		SFONode *foldingNode = SELFML(@"folding");
		
		if([languageDict objectForKey:@"foldingStartMarker"]) {
			SFONode *startFoldingNode = SELFML(@"start", [languageDict objectForKey:@"foldingStartMarker"]);
			[foldingNode addChild:startFoldingNode];
		}
		
		if([languageDict objectForKey:@"foldingStopMarker"]) {
			SFONode *stopFoldingNode = SELFML(@"stop", [languageDict objectForKey:@"foldingStopMarker"]);
			[foldingNode addChild:stopFoldingNode];
		}
		
		[rootNode addChild:foldingNode];
	}
	
	for(NSDictionary *prefItem in prefArray) {
		
		NSString *ruleScope = [prefItem objectForKey:@"scope"];
		if (![ruleScope length])
			continue;
		
		NSRange range = [ruleScope rangeOfString:rootScope options:NSCaseInsensitiveSearch];
		if (range.location != NSNotFound)
			continue;
		
		SFONode *ruleNode;
		if (range.location == 0 && range.length == [ruleScope length])
			ruleNode = rootNode;
		else
			ruleNode = SELFML(@"in", [prefItem objectForKey:@"scope"]);
		
		
		// if it's a completion, pass
		if([[prefItem objectForKey:@"settings"] objectForKey:@"completions"] != nil) {
			
		}
		
		
#pragma mark Pairing
		NSMutableDictionary *smartDict = [[NSMutableDictionary alloc] init];
		NSMutableDictionary *highlightDict = [[NSMutableDictionary alloc] init];
		
		// pairs (.)(.)
		if([[prefItem objectForKey:@"settings"] objectForKey:@"smartTypingPairs"] != nil) {
			for (NSArray *pair in [[prefItem objectForKey:@"settings"] objectForKey:@"smartTypingPairs"]) {
				// a smart pair!
				[smartDict setObject:[pair objectAtIndex:1] forKey:[pair objectAtIndex:0]];
			}
		}
		
		if([[prefItem objectForKey:@"settings"] objectForKey:@"highlightPairs"] != nil) {
			for (NSArray *pair in [[prefItem objectForKey:@"settings"] objectForKey:@"highlightPairs"]) {
				// a smart pair!
				[highlightDict setObject:[pair objectAtIndex:1] forKey:[pair objectAtIndex:0]];
			}
		}
		
		NSSet *keys = [[NSSet setWithArray:[smartDict allKeys]] setByAddingObjectsFromArray:[highlightDict allKeys]];
		
		for(NSString *key in keys) {
			// get the value first
			NSString *val;
			BOOL addSmart = NO;
			BOOL addHigh = NO;
			
			if([[smartDict allKeys] containsObject:key]) {
				val = [smartDict objectForKey:key];
				addSmart = YES;
			} 
			if ([[highlightDict allKeys] containsObject:key]) {
				val = [highlightDict objectForKey:key];
				addHigh = YES;
			}
			SFONode *pairNode = SELFML(@"pair", key, val);
			if(addSmart) {
				[pairNode addChild:SELFML(@"smart-typing")];
			}
			if(addHigh) {
				[pairNode addChild:SELFML(@"highlight")];
			}
			[ruleNode addChild:pairNode];
			
		}
		


#pragma mark Indentation
		
		// identation!
		if([[prefItem objectForKey:@"settings"] objectForKey:@"decreaseIndentPattern"] != nil) {
			SFONode *dintentNode = SELFML(@"indentation.decrease", [[prefItem objectForKey:@"settings"] objectForKey:@"decreaseIndentPattern"]);
			[ruleNode addChild:dintentNode];
		}
		
		if([[prefItem objectForKey:@"settings"] objectForKey:@"increaseIndentPattern"] != nil) {
			SFONode *intentNode = SELFML(@"indentation.increase", [[prefItem objectForKey:@"settings"] objectForKey:@"increaseIndentPattern"]);
			[ruleNode addChild:intentNode];
		}
		
		if([[prefItem objectForKey:@"settings"] objectForKey:@"indentNextLinePattern"] != nil) {
			SFONode *intentNlNode = SELFML(@"indentation.increase-next-line-only", [[prefItem objectForKey:@"settings"] objectForKey:@"indentNextLinePattern"]);
			[ruleNode addChild:intentNlNode];
		}
		
		if([[prefItem objectForKey:@"settings"] objectForKey:@"unIndentedLinePattern"] != nil) {
			SFONode *intentINode = SELFML(@"indentation.ignore-line", [[prefItem objectForKey:@"settings"] objectForKey:@"unIndentedLinePattern"]);
			[ruleNode addChild:intentINode];
		}
		
				
		// symbol list
		if([[prefItem objectForKey:@"settings"] objectForKey:@"showInSymbolList"] != nil) {
			SFONode *symbolNode = SELFML(@"symbol-list");
			
			if([[prefItem objectForKey:@"settings"] objectForKey:@"symbolTransformation"] != nil) {
				[symbolNode addChild:SELFML(@"transformation", [[prefItem objectForKey:@"settings"] objectForKey:@"symbolTransformation"])];
			}
			[ruleNode addChild:symbolNode];
		}
		
		// Comments
		if([[prefItem objectForKey:@"settings"] objectForKey:@"shellVariables"] != nil) {
			NSMutableDictionary *commentDict = [[NSMutableDictionary alloc] init];
			SFONode *shellVarNode = nil;
			for(NSDictionary *aVar in [[prefItem objectForKey:@"settings"] objectForKey:@"shellVariables"]) {
				if([[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_START"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_END"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_START_2"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_END_2"]) {
					[commentDict setObject:[aVar objectForKey:@"value"] forKey:[aVar objectForKey:@"name"]];
				} else {
					// it's a regular shell var
					if(shellVarNode == nil) {
						shellVarNode = SELFML(@"shell-variables");
					}
					[shellVarNode addChild:SELFML([aVar objectForKey:@"name"], [aVar objectForKey:@"value"])];
				}
			}
			
			if([commentDict objectForKey:@"TM_COMMENT_START"]) {
				SFONode *commentNode;
				if([commentDict objectForKey:@"TM_COMMENT_END"]) {
					// it's multiline
					commentNode = SELFML(@"comment.block", [commentDict objectForKey:@"TM_COMMENT_START"], [commentDict objectForKey:@"TM_COMMENT_END"]);
				} else {
					commentNode = SELFML(@"comment.line", [commentDict objectForKey:@"TM_COMMENT_START"]);
				}
				[ruleNode addChild:commentNode];

			}
			if([commentDict objectForKey:@"TM_COMMENT_START_2"]) {
				SFONode *commentNode2;
				if([commentDict objectForKey:@"TM_COMMENT_END_2"]) {
					// it's multiline
					commentNode2 = SELFML(@"comment.block", [commentDict objectForKey:@"TM_COMMENT_START_2"], [commentDict objectForKey:@"TM_COMMENT_END_2"]);
				} else {
					commentNode2 = SELFML(@"comment.line", [commentDict objectForKey:@"TM_COMMENT_START_2"]);
				}
				[ruleNode addChild:commentNode2];
			}
		}
		
		
		if (ruleNode != rootNode)
			[rootNode addChild:ruleNode];
	}
		
	NSLog(@"IQ: %@", [rootNode selfmlRepresentation]);
	
	[[rootNode selfmlRepresentation] writeToFile:[outputDir stringByAppendingPathComponent:@"iq.selfml"] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
}


#pragma mark -
#pragma mark Snippets 
void processSnippet(NSString *snippetPath, NSString *outputPath)
{
	NSDictionary *snippetAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:snippetPath] 
																		   options:0 
																			format:nil 
																			 error:nil];
	
	//NSDictionary *snippetAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:snippetPath] options:0 format:nil error:nil];
	NSString *newName = [[snippetPath lastPathComponent] stringByReplacingOccurrencesOfString:[snippetPath pathExtension] withString:@"selfml"];
	SFONode *rootNode = [SFONode node];
	SFONode *triggerNode = SELFML(@"trigger");
	// name
	if([snippetAsDic objectForKey:@"name"] != nil) {
		SFONode *nameNode = SELFML(@"name", [snippetAsDic objectForKey:@"name"]);
		//NSLog(@"FUCKING NAME: %@", [snippetAsDic objectForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	// tab trigger
	if([snippetAsDic objectForKey:@"tabTrigger"] != nil) {
		SFONode *tabNode = SELFML(@"tab", [snippetAsDic objectForKey:@"tabTrigger"]);
		[triggerNode addChild:tabNode];
	}
	
	[rootNode addChild:triggerNode];
	
	// scope
	if([snippetAsDic objectForKey:@"scope"] != nil) {
		SFONode *scopeNode = SELFML(@"only-in", [snippetAsDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// content! Let's see if Alex Gordon is as smart as he appears to be!
	if([snippetAsDic objectForKey:@"content"] != nil) {
		NSString *convertedSnippet = T2TConvertTextMateSnippetToChocolat([snippetAsDic objectForKey:@"content"]);
		if(convertedSnippet == nil)
			return; // bail..fuck that snippet
		SFONode *contentNode = SELFML(@"snippet", convertedSnippet);
		[rootNode addChild:contentNode];
	}
	
	// output to disk...
	NSString *outputFile = [[outputPath stringByAppendingPathComponent:@"snippets"] stringByAppendingPathComponent:newName];
	[[rootNode selfmlRepresentation] writeToFile:outputFile 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	//NSLog(@"%@", [rootNode selfmlRepresentation]);
}

void importSnippets(NSString *bundleRoot, NSString *outputFile)
{
	NSString *snippetsPath = [bundleRoot stringByAppendingPathComponent:@"Snippets"];
	NSMutableArray *snippets = [[NSMutableArray alloc] init];
	if(![[NSFileManager defaultManager] fileExistsAtPath:snippetsPath]) {
		NSLog(@"No snippets to import...continuing...");
		return;
	}
	// create the snippet directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputFile stringByAppendingPathComponent:@"snippets"]
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *snippet in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:snippetsPath error:nil]) {
		if([[[snippet pathExtension] lowercaseString] isEqual:@"tmsnippet"] || [[[snippet pathExtension] lowercaseString] isEqual:@"plist"]) {
			[snippets addObject:snippet];
		}
	}
	
	for(NSString *snippet in snippets) {
		processSnippet([snippetsPath stringByAppendingPathComponent:snippet], outputFile);
	}
	
}

#pragma mark -
#pragma mark Commands

void processCommand(NSString *fullPath, NSString *outputPath)
{
	NSString *fileName = [[[fullPath lastPathComponent] lowercaseString] stringByReplacingOccurrencesOfString:@" " withString:@"-"];
	NSString *fullFileName = [fileName stringByReplacingOccurrencesOfString:[fileName pathExtension] withString:@"selfml"];
	NSDictionary *commandDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:fullPath] options:0 format:nil error:nil];
	NSString *fullOutputPath = [outputPath stringByAppendingPathComponent:fullFileName];
	SFONode *rootNode = [SFONode node];
	
	// output equivalent dic
	NSMutableDictionary *outputDic = [[NSMutableDictionary alloc] init];
	[outputDic setObject:@"nothing" forKey:@"discard"];
	[outputDic setObject:@"replace-selected" forKey:@"replaceSelectedText"];
	[outputDic setObject:@"replace-all" forKey:@"replaceDocument"];
	[outputDic setObject:@"after-selected" forKey:@"afterSelectedText"];
	[outputDic setObject:@"snippet" forKey:@"insertAsSnippet"];
	[outputDic setObject:@"html" forKey:@"showAsHTML"];
	[outputDic setObject:@"tooltip" forKey:@"showAsTooltip"];
	[outputDic setObject:@"new-document" forKey:@"openAsNewDocument"];
	
	// beforeRunningCommand dic
	NSMutableDictionary *brcDic = [[NSMutableDictionary alloc] init];
	[brcDic setObject:@"nothing" forKey:@"nop"];
	[brcDic setObject:@"file" forKey:@"saveActiveFile"];
	[brcDic setObject:@"project" forKey:@"saveModifiedFiles"];
	
	// name
	if([commandDic objectForKey:@"name"] != nil) {
		SFONode *nameNode = SELFML(@"name", [commandDic objectForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	
	// scope
	if([commandDic objectForKey:@"scope"] != nil) {
		SFONode *scopeNode = SELFML(@"only-in", [commandDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// input
	if ([commandDic objectForKey:@"input"] != nil) {
		NSString *inputValue = ([[commandDic objectForKey:@"input"] isEqual:@"none"]) ? @"nothing" : [commandDic objectForKey:@"input"];
		SFONode *inputNode = SELFML(@"input", inputValue);
		
		if ([commandDic objectForKey:@"fallbackInput"] != nil) {
			[inputNode addChild:(NSString *)[commandDic objectForKey:@"fallbackInput"]];
		}
		
		[rootNode addChild:inputNode];
	}
	
	// output
	if([commandDic objectForKey:@"output"] != nil) {
		NSString *outputValue = [outputDic objectForKey:[commandDic objectForKey:@"output"]];
		SFONode *outputNode = SELFML(@"output", outputValue);
		[rootNode addChild:outputNode];
	}
	
	// brc
	if([commandDic objectForKey:@"beforeRunningCommand"] != nil) {
		SFONode *brcNode = SELFML(@"save", [brcDic objectForKey:[commandDic objectForKey:@"beforeRunningCommand"]]);
		[rootNode addChild:brcNode];
	}
	
	// src
	if([commandDic objectForKey:@"command"] != nil) {
		SFONode *commandNode = SELFML(@"script", [commandDic objectForKey:@"command"]);
		[rootNode addChild:commandNode];
	}
	
	[[rootNode selfmlRepresentation] writeToFile:fullOutputPath 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
}

void importCommands(NSString *bundleRoot, NSString *outputFile)
{
	NSString *commandsPath = [bundleRoot stringByAppendingPathComponent:@"Commands"];
	NSString *commandsOutputPath = [outputFile stringByAppendingPathComponent:@"commands"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	if(![[NSFileManager defaultManager] fileExistsAtPath:commandsPath]) {
		NSLog(@"No commnads to import...continuing...");
		return;
	}
	// create the snippet directory...
	[fm createDirectoryAtPath:commandsOutputPath
  withIntermediateDirectories:YES 
				   attributes:nil 
						error:nil];
	
	for(NSString *command in [fm contentsOfDirectoryAtPath:commandsPath error:nil]) {
		if([[[command pathExtension] lowercaseString] isEqual:@"tmcommand"] || [[[command pathExtension] lowercaseString] isEqual:@"plist"]) {
			processCommand([commandsPath stringByAppendingPathComponent:command], commandsOutputPath);
		}
	}
	
}


#pragma mark -
#pragma mark Language/Syntax

void processPattern(NSDictionary *pattern, SFONode **rootNode) {
	SFONode *nodePattern;
	
	// Deal with includes right alway
	if([pattern objectForKey:@"include"] != nil) {
		nodePattern = SELFML(@"include", [[pattern objectForKey:@"include"] stringByReplacingOccurrencesOfString:@"#" withString:@"@"]);
		[*rootNode addChild:nodePattern];
		return;
	}
	
	
	if([pattern objectForKey:@"name"] != nil) {
		nodePattern = SELFML(@"zone", [pattern objectForKey:@"name"]);
	} else {
		nodePattern = SELFML(@"zone");
		if([pattern objectForKey:@"contentName"] != nil) {
			SFONode *innerIdentifier = SELFML(@"inner-identifier", [pattern objectForKey:@"contentName"]);
			[nodePattern addChild:innerIdentifier];
		}
	}
	
	
	// match
	if([pattern objectForKey:@"match"] != nil) {
		SFONode *matchNode = SELFML(@"match");
		SFONode *regexNode = processRegex([pattern objectForKey:@"match"], &matchNode);
		
		
		//[matchNode addChild:regexNode];
		
		if([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *captureDic = [pattern objectForKey:@"captures"];
			
			if([captureDic objectForKey:@"contentName"] != nil){
				[matchNode addChild:(NSString *)[captureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [captureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[captureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		[nodePattern addChild:matchNode];
	}
	if([pattern objectForKey:@"begin"] != nil) {
		SFONode *startNode = SELFML(@"start");
		SFONode *regexNode = processRegex([pattern objectForKey:@"begin"], &startNode);
		
		if([pattern objectForKey:@"beginCaptures"] != nil) {
			NSDictionary *beginCaptureDic = [pattern objectForKey:@"beginCaptures"];
			
			if([beginCaptureDic objectForKey:@"contentName"] != nil){
				[startNode addChild:(NSString *)[beginCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [beginCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[beginCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		// is there a captures node?
		if([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *weirdCaptureDic = [pattern objectForKey:@"captures"];
			
			for(NSString *akey in [weirdCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *weirdCaptureNode = SELFML(akey, [[weirdCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:weirdCaptureNode];
				}
			}
		}
		
		[nodePattern addChild:startNode];
	}
	if([pattern objectForKey:@"end"] != nil) {
		SFONode *endNode = SELFML(@"end");
		SFONode *regexNode = processRegex([pattern objectForKey:@"end"], &endNode);
		
		if([pattern objectForKey:@"endCaptures"] != nil) {
			NSDictionary *endCaptureDic = [pattern objectForKey:@"endCaptures"];
			
			if([endCaptureDic objectForKey:@"contentName"] != nil){
				[endNode addChild:(NSString *)[endCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [endCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[endCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		
		// is there a captures node?
		if([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *weirdEndCaptureDic = [pattern objectForKey:@"captures"];
			
			for(NSString *akey in [weirdEndCaptureDic allKeys]) {
				if([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *weirdEndCaptureNode = SELFML(akey, [[weirdEndCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:weirdEndCaptureNode];
				}
			}
		}
		
		
		[nodePattern addChild:endNode];
	}
	
	// Deal with inner patterns...reccursively?
	if([pattern objectForKey:@"patterns"] != nil) {
		SFONode *subzoneNode = SELFML(@"subzones");
		for(NSDictionary *subpattern in [pattern valueForKey:@"patterns"]) {
			processPattern(subpattern, &subzoneNode);
		}
		[nodePattern addChild:subzoneNode];
	}
	
	//NSLog(@"Zone: %@", [nodePattern selfmlRepresentation]);
	[*rootNode addChild:nodePattern];
}

void processLanguage(NSString *bundleRoot, NSString *languagePath, NSString *outputPath)
{
	NSDictionary *languageAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:languagePath] options:0 format:nil error:nil];
	
	NSString *bundleSourceName = [languageAsDic valueForKey:@"scopeName"];
	NSMutableArray *components = [[bundleSourceName componentsSeparatedByString:@"."] mutableCopy];
	[components removeObject:@"source"];
	[components removeObject:@"sourcecode"];
	NSString *outputDirName = [[components componentsJoinedByString:@"."] stringByReplacingOccurrencesOfString:@"/" withString:@""];
	
	// Create the output directory
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputPath stringByAppendingPathComponent:outputDirName]
							  withIntermediateDirectories:NO 
											   attributes:nil 
													error:nil];
	
	NSString *rootScope = [languageAsDic valueForKey:@"scopeName"];
	if (![rootScope length])
		return;
	
	SFONode *rootNode = SELFML(@"root", rootScope);
	SFONode *ubberRootNode = [SFONode node];
	
	// patterns...
	for(NSDictionary *pattern in [languageAsDic valueForKey:@"patterns"])
	{
		processPattern(pattern, &rootNode);
	}
	
	[ubberRootNode addChild:rootNode];
	// collections/repo
	for(NSString *repoKey in [languageAsDic objectForKey:@"repository"]) {
		SFONode *collectionNode = SELFML(@"collection", repoKey);
		NSDictionary *collectionDic = [[languageAsDic objectForKey:@"repository"] objectForKey:repoKey];
		// is it the dumb exception?
		if([[collectionDic allKeys] count] == 1 && [collectionDic objectForKey:@"patterns"] != nil) {
			// yes it is!
			for(NSDictionary *subzone in [collectionDic objectForKey:@"patterns"]) {
				processPattern(subzone, &collectionNode);
			}
		} else {
			processPattern(collectionDic, &collectionNode);
		}
		
		
		[ubberRootNode addChild:collectionNode];
	}
	
	
	[[ubberRootNode selfmlRepresentation] writeToFile:[[outputPath stringByAppendingPathComponent:outputDirName] stringByAppendingPathComponent:@"syntax.selfml"] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
	
	processIq(bundleRoot, [outputPath stringByAppendingPathComponent:outputDirName], rootScope, languageAsDic);
	
	//NSLog(@"Out: %@", [rootNode selfmlRepresentation]);
}

void importLanguages(NSString *bundleRoot, NSString *outputFile)
{
	NSString *syntaxInPath = [bundleRoot stringByAppendingPathComponent:@"Syntaxes"];
	NSString *syntaxOutPath = [outputFile stringByAppendingPathComponent:@"languages"];
	
	
	// create the languages directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:syntaxOutPath
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *language in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:syntaxInPath error:nil]) {
		if([[[language pathExtension] lowercaseString] isEqual:@"tmlanguage"] || [[[language pathExtension] lowercaseString] isEqual:@"plist"]) {
			processLanguage(bundleRoot, [syntaxInPath stringByAppendingPathComponent:language], syntaxOutPath);
		}
	}
	
}

#pragma mark -
#pragma mark Resources

void copyResources(NSString *bundleRoot, NSString *outputFile)
{
	NSString *supportDir = [bundleRoot stringByAppendingPathComponent:@"Support"];
	NSString *destinationPath = [outputFile stringByAppendingPathComponent:@"resources"];
	
	if(![[NSFileManager defaultManager] fileExistsAtPath:supportDir]) 
		return;
	
	
	[[NSFileManager defaultManager] copyItemAtPath:supportDir toPath:destinationPath error:nil];
	
	
}

#pragma mark -
#pragma mark Templates
void processTemplateFile(NSString *fullPath, SFONode **rootNode, BOOL isPrimary) 
{
	NSString *fileName = [fullPath lastPathComponent];
	NSString *displayName = [fileName stringByDeletingPathExtension];
	NSString *fileContent = [NSString stringWithContentsOfFile:fullPath encoding:NSUTF8StringEncoding error:nil];
	NSString *convertedContent = T2TConvertTextMateSnippetToChocolat(fileContent);
	SFONode *fileNode;
	if(isPrimary) {
		fileNode = SELFML(@"file.primary");
	} else {
		fileNode = SELFML(@"file");
	}
	//name
	SFONode *nameNode = SELFML(@"name", displayName);
	[fileNode addChild:nameNode];
	
	//file name
	SFONode *filenameNode = SELFML(@"filename", fileName);
	[fileNode addChild:filenameNode];
	
	//content
	SFONode *contentNode = SELFML(@"contents", convertedContent);
	[fileNode addChild:contentNode];
	
	
	[*rootNode addChild:fileNode];
}


void processTemplate(NSString *fullPath, NSString *outputDir, NSString *bundleRoot)
{
	// OK so, the info.plist contains the meta data about the template,
	// every other file in there is an actual template!
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaData = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[fullPath stringByAppendingPathComponent:@"info.plist"]]
																	   options:0 
																		format:nil 
																		 error:nil];
	
	NSDictionary *bundleMetaData = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[bundleRoot stringByAppendingPathComponent:@"info.plist"]]
																			 options:0 
																			  format:nil 
																			   error:nil];
	
	NSString *fileName;
	// first the name!
	if([metaData objectForKey:@"name"]) {
		SFONode *nameNode = SELFML(@"name", [metaData valueForKey:@"name"]);
		[rootNode addChild:nameNode];
		fileName = [[metaData valueForKey:@"name"] stringByAppendingString:@".selfml"];
	} else {
		return;
	}
	// Group
	SFONode *platformNode = SELFML(@"group.platform", @"Misc");
	[rootNode addChild:platformNode];
	
	// Get the name of the bundle...
	SFONode *principleNode;
	if([bundleMetaData objectForKey:@"name"] != nil) {
		principleNode = SELFML(@"group.principles", [bundleMetaData objectForKey:@"name"]);
	} else {
		principleNode = SELFML(@"group.principles", @"Unknown");
	}
	[rootNode addChild:principleNode];
	
	// now process the template files...
	int i = 0;
	BOOL primary;
	for(NSString *aFile in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:fullPath error:nil]) {
		if(![[aFile lowercaseString] isEqual:@"info.plist"]) {
			processTemplateFile([fullPath stringByAppendingPathComponent:aFile], &rootNode, (i == 0) );
			i++;
		}
	}
	
	
	[[rootNode selfmlRepresentation] writeToFile:[outputDir stringByAppendingPathComponent:fileName] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
	//NSLog(@"Template: %@", [rootNode selfmlRepresentation]);
}

void importTemplates(NSString *bundleRoot, NSString *outputFile)
{
	NSString *templatePath = [bundleRoot stringByAppendingPathComponent:@"Templates"];
	NSString *templateOutputDir = [outputFile stringByAppendingPathComponent:@"templates"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	// do we have to import them?
	if(![fm fileExistsAtPath:templatePath]) {
		NSLog(@"No templates, continuing!");
		return;
	}
	// create the template output dir...
	[fm createDirectoryAtPath:templateOutputDir attributes:nil];
	
	// Get the full path and process it!
	for(NSString *templateDir in [fm contentsOfDirectoryAtPath:templatePath error:nil]) {
		processTemplate([templatePath stringByAppendingPathComponent:templateDir], templateOutputDir, bundleRoot);
	}
	
}



