#import "utils.h"
#import "SFONode.h"
#import "RegexKitLite.h"
#import "T2TSnippetConverterShared.h"
#import "T2TSnippetConverterLexer.h"
#import "T2TKeyEquivalentConverter.h"

NSString* T2TSanatizeRepresentationIdentifier(NSString* repid)
{
	repid = [repid lowercaseString];
	
	NSMutableCharacterSet *charset = [NSMutableCharacterSet whitespaceAndNewlineCharacterSet];
	[charset addCharactersInString:@"/\\:"];
	
	NSMutableArray *repid_comps = [[repid componentsSeparatedByCharactersInSet:charset] mutableCopy];
	[repid_comps removeObject:@""];
	if (![repid_comps count])
		return @"untitled";
	
	return [repid_comps componentsJoinedByString:@"-"];
}


#pragma mark -
#pragma mark Metadata
int importMetaData(NSString *bundleRoot, NSString *outputFile)
{
	NSFileManager *fm = [NSFileManager defaultManager];
	NSString *metaDataPath = [bundleRoot stringByAppendingPathComponent:@"info.plist"];
	NSString *metaDataOutputPath = [outputFile stringByAppendingPathComponent:@"truffle.selfml"];
	if (![fm fileExistsAtPath:metaDataPath]) {
		NSLog(@"This is not normal...No info.plist, can't import! DUCK AND COVER!");
		return 0;
	}
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:metaDataPath] options:0 format:nil error:nil];
	
	// provider...
	NSString *provider;
	if ([metaDic objectForKey:@"contactName"] != nil) {
		provider = T2TSanatizeRepresentationIdentifier([metaDic objectForKey:@"contactName"]);
	} else {
		provider = @"private.anonymous";
	}
	SFONode *providerNode = SELFML(@"provider", provider);
	[rootNode addChild:providerNode];
	
	// name
	if ([metaDic objectForKey:@"contactName"] != nil) {
		SFONode *nameNode = SELFML(@"author", [metaDic objectForKey:@"contactName"]);
		[rootNode addChild:nameNode];
	}
	
	
	// email
	if ([metaDic objectForKey:@"contactEmailRot13"] != nil) {
		SFONode *emailNode = SELFML(@"rot-13-email", [metaDic objectForKey:@"contactEmailRot13"]);
		[rootNode addChild:emailNode];
	}
	
	[[@"### Generated by tm2truffle\n\n" stringByAppendingString:[rootNode selfmlRepresentation]] writeToFile:metaDataOutputPath 
																								   atomically:YES 
																									 encoding:NSUTF8StringEncoding 
																										error:nil];
		
	return 1;
}

#pragma mark -
#pragma mark Useful stuff
int createOutputDir(NSString *outputFile) 
{
	BOOL isDir;
	if (! [[NSFileManager defaultManager] fileExistsAtPath:outputFile isDirectory:&isDir] || !isDir) {
		NSError *error = nil;
		[[NSFileManager defaultManager] createDirectoryAtPath:outputFile 
								  withIntermediateDirectories:YES 
												   attributes:nil 
														error:&error];
		if (error) {
			NSLog(@"%@", [error localizedDescription]);
			return 0;
		}
		
		
	}
	return 1;
}

NSMutableArray* loadPreferences(NSString *bundleRoot) {
	NSMutableArray *prefArray = [[NSMutableArray alloc] init];
	NSString *prefPath = [bundleRoot stringByAppendingPathComponent:@"Preferences"];
	for(NSString *prefFile in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:prefPath error:nil]) {
		NSDictionary *prefDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[prefPath stringByAppendingPathComponent:prefFile]] 
																		  options:0 
																		   format:nil 
																			error:nil];
		[prefArray addObject:prefDic];
	}
	
	//NSLog(@"Prefs: %@", prefArray);
	return prefArray;
	
}

SFONode *processRegex(NSString *regex, SFONode **parentNode, BOOL shouldSimplify)
{
	if (shouldSimplify)
	{
		NSString *stringRegex = @"^(\\(\\?i\\))?(\\^)?(\\\\b)?([^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+)(\\\\b)?(\\$)?$";
		
		if ([regex rangeOfRegex:stringRegex].location != NSNotFound) {
			NSArray *matches = [regex arrayOfCaptureComponentsMatchedByRegex:stringRegex];
			[*parentNode addChild:[[matches lastObject] objectAtIndex:4]];
			// process its flags
			if ([[[matches lastObject] objectAtIndex:1] length]) {
				// ignore case
				SFONode *ignoreCaseNode = SELFML(@"ignore-case");
				[*parentNode addChild:ignoreCaseNode];
			}
			if ([[[matches lastObject] objectAtIndex:2] length] > 0 && [[[matches lastObject] objectAtIndex:6] length] > 0) {
				// anchor both
				SFONode *abothCaseNode = SELFML(@"anchor.both");
				[*parentNode addChild:abothCaseNode];
			} else if ([[[matches lastObject] objectAtIndex:2] length] > 0) {
				// anchor left
				SFONode *aleftCaseNode = SELFML(@"anchor.left");
				[*parentNode addChild:aleftCaseNode];
			}else if ([[[matches lastObject] objectAtIndex:6] length] > 0) {
				// anchor right
				SFONode *arightCaseNode = SELFML(@"anchor.right");
				[*parentNode addChild:arightCaseNode];
			}
			
			if ([[[matches lastObject] objectAtIndex:3] length] > 0 && [[[matches lastObject] objectAtIndex:5] length] > 0) {
				// boundary both
				SFONode *bbothCaseNode = SELFML(@"boundary.both");
				[*parentNode addChild:bbothCaseNode];
			} else if ([[[matches lastObject] objectAtIndex:3] length] > 0) {
				// boundary left
				SFONode *bleftCaseNode = SELFML(@"boundary.left");
				[*parentNode addChild:bleftCaseNode];
			}else if ([[[matches lastObject] objectAtIndex:5] length] > 0) {
				// boundary right
				SFONode *brightCaseNode = SELFML(@"boundary.right");
				[*parentNode addChild:brightCaseNode];
			}
			
			return nil;
			//NSLog(@"IT'S A STRING: %@\nMatches: %@", regex, matches);
		}
		
		NSString *listRegex = @"^(\\(\\?i\\))?(\\^)?(\\\\b)?(\\([^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+(\\|[^\\[\\\\\\^\\$\\.\\|\\?\\*\\+\\(\\)]+)*\\))(\\\\b)?(\\$)?$";
		if ([regex rangeOfRegex:listRegex].location != NSNotFound) {
			SFONode *listNode = SELFML(@"list");
			NSArray *matches = [regex arrayOfCaptureComponentsMatchedByRegex:listRegex];
			
			// list items
			NSString *contentWithoutParen = [[[matches lastObject] objectAtIndex:4] substringWithRange:NSMakeRange(1, [[[matches lastObject] objectAtIndex:4] length] -2)];
			for(NSString *item in [contentWithoutParen componentsSeparatedByString:@"|"]) {
				[listNode addChild:item];
			}
			
			[*parentNode addChild:listNode];
			
			// process its flags
			if ([[[matches lastObject] objectAtIndex:1] length]) {
				// ignore case
				SFONode *ignoreCaseNode = SELFML(@"ignore-case");
				[*parentNode addChild:ignoreCaseNode];
			}
			
			if ([[[matches lastObject] objectAtIndex:2] length] > 0 && [[[matches lastObject] objectAtIndex:7] length] > 0) {
				// anchor both
				SFONode *abothCaseNode = SELFML(@"anchor.both");
				[*parentNode addChild:abothCaseNode];
			} else if ([[[matches lastObject] objectAtIndex:2] length] > 0) {
				// anchor left
				SFONode *aleftCaseNode = SELFML(@"anchor.left");
				[*parentNode addChild:aleftCaseNode];
			}else if ([[[matches lastObject] objectAtIndex:7] length] > 0) {
				// anchor right
				SFONode *arightCaseNode = SELFML(@"anchor.right");
				[*parentNode addChild:arightCaseNode];
			}
			
			if ([[[matches lastObject] objectAtIndex:3] length] > 0 && [[[matches lastObject] objectAtIndex:6] length] > 0) {
				// boundary both
				SFONode *bbothCaseNode = SELFML(@"boundary.both");
				[*parentNode addChild:bbothCaseNode];
			} else if ([[[matches lastObject] objectAtIndex:3] length] > 0) {
				// boundary left
				SFONode *bleftCaseNode = SELFML(@"boundary.left");
				[*parentNode addChild:bleftCaseNode];
			}else if ([[[matches lastObject] objectAtIndex:6] length] > 0) {
				// boundary right
				SFONode *brightCaseNode = SELFML(@"boundary.right");
				[*parentNode addChild:brightCaseNode];
			}
			
			
			
			return nil;
		}
	}
	
	
	SFONode *regexNode = SELFML(@"regex", regex);
	[*parentNode addChild:regexNode];
	return regexNode;
}




#pragma mark -
#pragma mark Booya
void processIq(NSString *bundleRoot, NSString *outputDir, NSString *rootScope, NSDictionary *languageDict)
{
	NSArray *prefArray = loadPreferences(bundleRoot);
	SFONode *rootNode = [SFONode node];
	SFONode *placeholderNode = nil;
	NSString *outputPHDir = [[[outputDir stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"placeholder-themes"];
	
#pragma mark Detectors
	if ([[languageDict objectForKey:@"fileTypes"] count] != nil) {
		SFONode *extDetectorNode = SELFML(@"detector");
		for(NSString *ext in [languageDict objectForKey:@"fileTypes"]) {
			SFONode *anExtNode = SELFML(@"extension", ext);
			[extDetectorNode addChild:anExtNode];
		}
		[rootNode addChild:extDetectorNode];
	}
	
	if ([[languageDict objectForKey:@"firstLineMatch"] length] != nil) {
		SFONode *contentMatchDetectorNode = SELFML(@"detector");
		SFONode *regexContentMatchNode = SELFML(@"content-matches", [languageDict objectForKey:@"firstLineMatch"]);
		[contentMatchDetectorNode addChild:regexContentMatchNode];
		[rootNode addChild:contentMatchDetectorNode];
	}
	
#pragma mark Folding
	if ([[languageDict objectForKey:@"foldingStartMarker"] length] && [[languageDict objectForKey:@"foldingStopMarker"] length]) {
		SFONode *foldingNode = SELFML(@"folding");
		
	//	if ([languageDict objectForKey:@"foldingStartMarker"]) {
			SFONode *startFoldingNode = SELFML(@"start", [languageDict objectForKey:@"foldingStartMarker"]);
			[foldingNode addChild:startFoldingNode];
	//	}
		
	//	if ([languageDict objectForKey:@"foldingStopMarker"]) {
			SFONode *stopFoldingNode = SELFML(@"stop", [languageDict objectForKey:@"foldingStopMarker"]);
			[foldingNode addChild:stopFoldingNode];
	//	}
		
		[rootNode addChild:foldingNode];
	}
	
	for(NSDictionary *prefItem in prefArray) {
		NSString *ruleScope = [prefItem objectForKey:@"scope"];
		//NSLog(@"ruleScope = %@", ruleScope);
		//NSLog(@"prefItem = %@", prefItem);
		if (![ruleScope length])
			continue;
		
		NSRange range = [ruleScope rangeOfString:rootScope options:NSCaseInsensitiveSearch];
		//NSLog(@"rootScope = %@", rootScope);
		//NSLog(@"range = %@", NSStringFromRange(range));
		//if (range.location != NSNotFound)
		//	continue;
		
		SFONode *ruleNode;
		if (range.location == 0 && range.length == [ruleScope length])
			ruleNode = rootNode;
		else
			ruleNode = SELFML(@"in", [prefItem objectForKey:@"scope"]);
		
		
		// if it's a completion, pass
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"completions"] != nil) {
			
		}
		
#pragma mark Placeholder Themes
		// placeholder themes..try to deal with the fuckers...
		if ([[[prefItem objectForKey:@"settings"] allKeys] containsObject:@"background"] ||
			[[[prefItem objectForKey:@"settings"] allKeys] containsObject:@"foreground"] ||
			[[[prefItem objectForKey:@"settings"] allKeys] containsObject:@"fontStyle"]) {
			
			NSDictionary *settings = [prefItem objectForKey:@"settings"];
			
			
			if (placeholderNode == nil) {
				// create the node if it doesn't exist
				placeholderNode = [SFONode node];
			}
			
			SFONode *zoneNode = SELFML(@"apply", [prefItem objectForKey:@"scope"], [prefItem objectForKey:@"name"]);
			// foreground
			if([settings objectForKey:@"foreground"] != nil) {
				SFONode *fgNode = SELFML(@"color", [[settings objectForKey:@"foreground"] stringByReplacingOccurrencesOfString:@"#" withString:@""]);
				[zoneNode addChild:fgNode];
			}
			
			// bg
			if([settings objectForKey:@"background"] != nil) {
				SFONode *bgNode = SELFML(@"background", [[settings objectForKey:@"background"] stringByReplacingOccurrencesOfString:@"#" withString:@""]);
				[zoneNode addChild:bgNode];
			}
			
			// styles
			if([settings objectForKey:@"fontStyle"] != nil) {
				NSString *styles = [settings objectForKey:@"fontStyle"];
				if([styles rangeOfString:@"italic"].location != NSNotFound) {
					SFONode *italicNode = SELFML(@"italic");
					[zoneNode addChild:italicNode];
				}
				
				if([styles rangeOfString:@"bold"].location != NSNotFound) {
					SFONode *boldNode = SELFML(@"bold");
					[zoneNode addChild:boldNode];
				}
				
				if([styles rangeOfString:@"underline"].location != NSNotFound) {
					SFONode *underlineNode = SELFML(@"underline");
					[zoneNode addChild:underlineNode];
				}
			}
			
			[placeholderNode addChild:zoneNode];
			
			continue;
		}
		
		
#pragma mark Pairing
		NSMutableDictionary *smartDict = [[NSMutableDictionary alloc] init];
		NSMutableDictionary *highlightDict = [[NSMutableDictionary alloc] init];
		
		// pairs (.)(.)
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"smartTypingPairs"] != nil) {
			for (NSArray *pair in [[prefItem objectForKey:@"settings"] objectForKey:@"smartTypingPairs"]) {
				// a smart pair!
				[smartDict setObject:[pair objectAtIndex:1] forKey:[pair objectAtIndex:0]];
			}
		}
		
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"highlightPairs"] != nil) {
			for (NSArray *pair in [[prefItem objectForKey:@"settings"] objectForKey:@"highlightPairs"]) {
				// a smart pair!
				[highlightDict setObject:[pair objectAtIndex:1] forKey:[pair objectAtIndex:0]];
			}
		}
		
		NSSet *keys = [[NSSet setWithArray:[smartDict allKeys]] setByAddingObjectsFromArray:[highlightDict allKeys]];
		
		for(NSString *key in keys) {
			// get the value first
			NSString *val;
			BOOL addSmart = NO;
			BOOL addHigh = NO;
			
			if ([[smartDict allKeys] containsObject:key]) {
				val = [smartDict objectForKey:key];
				addSmart = YES;
			} 
			if ([[highlightDict allKeys] containsObject:key]) {
				val = [highlightDict objectForKey:key];
				addHigh = YES;
			}
			SFONode *pairNode = SELFML(@"pair", key, val);
			if (addSmart) {
				[pairNode addChild:SELFML(@"smart-typing")];
			}
			if (addHigh) {
				[pairNode addChild:SELFML(@"highlight")];
			}
			[ruleNode addChild:pairNode];
			
		}
		


#pragma mark Indentation
		
		// identation!
		//NSLog(@"______ INDENT!");
		if ([[[prefItem objectForKey:@"settings"] objectForKey:@"decreaseIndentPattern"] length] != nil) {
		//NSLog(@"______ DECREASE!");
			SFONode *dintentNode = SELFML(@"indentation.decrease", [[prefItem objectForKey:@"settings"] objectForKey:@"decreaseIndentPattern"]);
			//NSLog(@"| dintentNode = %@", [dintentNode selfmlRepresentation]);
			[ruleNode addChild:dintentNode];
			//NSLog(@"| ruleNode = %@", [ruleNode selfmlRepresentation]);
		}
		
		if ([[[prefItem objectForKey:@"settings"] objectForKey:@"increaseIndentPattern"] length] != nil) {
			SFONode *intentNode = SELFML(@"indentation.increase", [[prefItem objectForKey:@"settings"] objectForKey:@"increaseIndentPattern"]);
			[ruleNode addChild:intentNode];
		}
		
		if ([[[prefItem objectForKey:@"settings"] objectForKey:@"indentNextLinePattern"] length] != nil) {
			SFONode *intentNlNode = SELFML(@"indentation.increase-next-line-only", [[prefItem objectForKey:@"settings"] objectForKey:@"indentNextLinePattern"]);
			[ruleNode addChild:intentNlNode];
		}
		
		if ([[[prefItem objectForKey:@"settings"] objectForKey:@"unIndentedLinePattern"] length] != nil) {
			SFONode *intentINode = SELFML(@"indentation.ignore-line", [[prefItem objectForKey:@"settings"] objectForKey:@"unIndentedLinePattern"]);
			[ruleNode addChild:intentINode];
		}
		
				
		// symbol list
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"showInSymbolList"] != nil) {
			SFONode *symbolNode = SELFML(@"symbol-list");
			
			if ([[[prefItem objectForKey:@"settings"] objectForKey:@"symbolTransformation"] length] != nil) {
				[symbolNode addChild:SELFML(@"transformation", [[prefItem objectForKey:@"settings"] objectForKey:@"symbolTransformation"])];
			}
			[ruleNode addChild:symbolNode];
		}
		
		// spell checking
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"spellChecking"]) {
			SFONode *spellCheckingNode;
			if ([[[prefItem objectForKey:@"settings"] objectForKey:@"spellChecking"] intValue] == 1) {
				spellCheckingNode = SELFML(@"spellchecking");
			} else {
				spellCheckingNode = SELFML(@"no-spellchecking");
			}
			[ruleNode addChild:spellCheckingNode];
		}
		
		// Comments
		if ([[prefItem objectForKey:@"settings"] objectForKey:@"shellVariables"] != nil) {
			NSMutableDictionary *commentDict = [[NSMutableDictionary alloc] init];
			SFONode *shellVarNode = nil;
			for(NSDictionary *aVar in [[prefItem objectForKey:@"settings"] objectForKey:@"shellVariables"]) {

				if (shellVarNode == nil) {
					shellVarNode = SELFML(@"shell-variables");
				}
				
				[shellVarNode addChild:SELFML([aVar objectForKey:@"name"], [aVar objectForKey:@"value"])];
				
				// if it's a comment, process it...
				if ([[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_START"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_END"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_START_2"] || 
				   [[aVar objectForKey:@"name"] isEqual:@"TM_COMMENT_END_2"]) {
					[commentDict setObject:[aVar objectForKey:@"value"] forKey:[aVar objectForKey:@"name"]];
				}
			}
			[ruleNode addChild:shellVarNode];
			if ([commentDict objectForKey:@"TM_COMMENT_START"]) {
				SFONode *commentNode;
				if ([commentDict objectForKey:@"TM_COMMENT_END"]) {
					// it's multiline
					commentNode = SELFML(@"comment.block", [commentDict objectForKey:@"TM_COMMENT_START"], [commentDict objectForKey:@"TM_COMMENT_END"]);
				} else {
					commentNode = SELFML(@"comment.line", [commentDict objectForKey:@"TM_COMMENT_START"]);
				}
				[ruleNode addChild:commentNode];

			}
			if ([commentDict objectForKey:@"TM_COMMENT_START_2"]) {
				SFONode *commentNode2;
				if ([commentDict objectForKey:@"TM_COMMENT_END_2"]) {
					// it's multiline
					commentNode2 = SELFML(@"comment.block", [commentDict objectForKey:@"TM_COMMENT_START_2"], [commentDict objectForKey:@"TM_COMMENT_END_2"]);
				} else {
					commentNode2 = SELFML(@"comment.line", [commentDict objectForKey:@"TM_COMMENT_START_2"]);
				}
				[ruleNode addChild:commentNode2];
			}
		}
		
		//NSLog(@"______ ADDING! %d %d %d", ruleNode, rootNode, ruleNode == rootNode);
		
		if (ruleNode != rootNode)
			[rootNode addChild:ruleNode];
	}
	
	// output placeholder themes if there were any
	if (placeholderNode != nil) {
		// create dir if it doesn't exist...
		if (![[NSFileManager defaultManager] fileExistsAtPath:outputPHDir]) {
			[[NSFileManager defaultManager] createDirectoryAtPath:outputPHDir 
									  withIntermediateDirectories:NO 
													   attributes:nil 
															error:nil];
			
		}
		NSString *ptFileName = [outputPHDir stringByAppendingPathComponent:@"styles.selfml"];
		[[placeholderNode selfmlRepresentation] writeToFile:ptFileName 
												 atomically:YES 
												   encoding:NSUTF8StringEncoding 
													  error:nil];
	}
	
	//NSLog(@"[rootNode selfmlRepresentation] = %@", [rootNode selfmlRepresentation]);
	[[rootNode selfmlRepresentation] writeToFile:[outputDir stringByAppendingPathComponent:@"iq.selfml"] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
}


#pragma mark -
#pragma mark Snippets 
void processSnippet(NSString *snippetPath, NSString *outputPath)
{
	NSDictionary *snippetAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:snippetPath] 
																		   options:0 
																			format:nil 
																			 error:nil];
	
	//NSDictionary *snippetAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:snippetPath] options:0 format:nil error:nil];
	NSString *newName = [[snippetPath lastPathComponent] stringByReplacingOccurrencesOfString:[snippetPath pathExtension] withString:@"selfml"];
	SFONode *rootNode = [SFONode node];
	SFONode *triggerNode = SELFML(@"trigger");
	// name
	if ([[snippetAsDic objectForKey:@"name"] length] != nil) {
		SFONode *nameNode = SELFML(@"name", [snippetAsDic objectForKey:@"name"]);

		[rootNode addChild:nameNode];
	}
	
	// key equiv trigger
	if ([[snippetAsDic objectForKey:@"keyEquivalent"] length] != nil) {
		NSArray *keyEquivArray = T2TConvertKeyEquivalent([snippetAsDic objectForKey:@"keyEquivalent"]);
		SFONode *keyNode = SELFML(@"key", [keyEquivArray componentsJoinedByString:@""]);
		[triggerNode addChild:keyNode];
	}
	
	// tab trigger
	if ([[snippetAsDic objectForKey:@"tabTrigger"] length] != nil) {
		SFONode *tabNode = SELFML(@"tab", [snippetAsDic objectForKey:@"tabTrigger"]);
		[triggerNode addChild:tabNode];
	}
	
	[rootNode addChild:triggerNode];
	
	// scope
	if ([[snippetAsDic objectForKey:@"scope"] length] != nil) {
		SFONode *scopeNode = SELFML(@"only-in", [snippetAsDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// content! Let's see if Alex Gordon is as smart as he appears to be!
	if ([[snippetAsDic objectForKey:@"content"] length] != nil) {
		NSString *convertedSnippet = T2TConvertTextMateSnippetToChocolat([snippetAsDic objectForKey:@"content"]);
		if (![convertedSnippet length])
			return; // bail..fuck that snippet


		// Apparently he is!
		SFONode *contentNode = SELFML(@"snippet", convertedSnippet);
		[rootNode addChild:contentNode];
	}
	
	// output to disk...
	NSString *outputFile = [[outputPath stringByAppendingPathComponent:@"snippets"] stringByAppendingPathComponent:newName];
	[[rootNode selfmlRepresentation] writeToFile:outputFile 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
}

void importSnippets(NSString *bundleRoot, NSString *outputFile)
{
	NSString *snippetsPath = [bundleRoot stringByAppendingPathComponent:@"Snippets"];
	NSMutableArray *snippets = [[NSMutableArray alloc] init];
	if (![[NSFileManager defaultManager] fileExistsAtPath:snippetsPath]) {
		return;
	}
	// create the snippet directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputFile stringByAppendingPathComponent:@"snippets"]
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *snippet in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:snippetsPath error:nil]) {
		if ([[[snippet pathExtension] lowercaseString] isEqual:@"tmsnippet"] || [[[snippet pathExtension] lowercaseString] isEqual:@"plist"]) {
			[snippets addObject:snippet];
		}
	}
	
	for(NSString *snippet in snippets) {
		processSnippet([snippetsPath stringByAppendingPathComponent:snippet], outputFile);
	}
	
}

#pragma mark -
#pragma mark DragCommands
void processDragCommand(NSString *fullPath, NSString *outputPath)
{
	NSString *fileName = T2TSanatizeRepresentationIdentifier([fullPath lastPathComponent]);
	NSString *fullFileName = [fileName stringByReplacingOccurrencesOfString:[fileName pathExtension] withString:@"selfml"];
	NSDictionary *commandDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:fullPath] options:0 format:nil error:nil];
	NSString *fullOutputPath = [outputPath stringByAppendingPathComponent:fullFileName];
	SFONode *rootNode = [SFONode node];
	
	// output equivalent dic
	NSMutableDictionary *outputDic = [[NSMutableDictionary alloc] init];
	[outputDic setObject:@"nothing" forKey:@"discard"];
	[outputDic setObject:@"replace-selected" forKey:@"replaceSelectedText"];
	[outputDic setObject:@"replace-all" forKey:@"replaceDocument"];
	[outputDic setObject:@"after-selected" forKey:@"afterSelectedText"];
	[outputDic setObject:@"snippet" forKey:@"insertAsSnippet"];
	[outputDic setObject:@"html" forKey:@"showAsHTML"];
	[outputDic setObject:@"tooltip" forKey:@"showAsTooltip"];
	[outputDic setObject:@"new-document" forKey:@"openAsNewDocument"];
	
	// beforeRunningCommand dic
	NSMutableDictionary *brcDic = [[NSMutableDictionary alloc] init];
	[brcDic setObject:@"nothing" forKey:@"nop"];
	[brcDic setObject:@"file" forKey:@"saveActiveFile"];
	[brcDic setObject:@"project" forKey:@"saveModifiedFiles"];
	
	
	// name
	if ([[commandDic objectForKey:@"name"] length] != nil) {
		SFONode *nameNode = SELFML(@"name", [commandDic objectForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	
	// scope
	if ([[commandDic objectForKey:@"scope"] length] != nil) {
		SFONode *scopeNode = SELFML(@"only-in", [commandDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// output
	if ([[commandDic objectForKey:@"output"] length] != nil) {
		NSString *outputValue = [outputDic objectForKey:[commandDic objectForKey:@"output"]];
		SFONode *outputNode = SELFML(@"output", outputValue);
		[rootNode addChild:outputNode];
	}
	
	// file-extensions
	if ([[commandDic objectForKey:@"draggedFileExtensions"] count] != nil) {
		SFONode *extDetectorNode = SELFML(@"file-extensions");
		for(NSString *ext in [commandDic objectForKey:@"draggedFileExtensions"]) {
			if ([ext length])
				[extDetectorNode addChild:ext];
		}
		[rootNode addChild:extDetectorNode];
	}
	
	// brc
	if ([[commandDic objectForKey:@"beforeRunningCommand"] length] != nil) {
		SFONode *brcNode = SELFML(@"save", [brcDic objectForKey:[commandDic objectForKey:@"beforeRunningCommand"]]);
		[rootNode addChild:brcNode];
	}
	
	// src
	if ([[commandDic objectForKey:@"command"] length] != nil) {
		SFONode *commandNode = SELFML(@"script", [commandDic objectForKey:@"command"]);
		[rootNode addChild:commandNode];
	}
	
	[[rootNode selfmlRepresentation] writeToFile:fullOutputPath 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
}


void importDragCommands(NSString *bundleRoot, NSString *outputFile)
{
	NSString *commandsPath = [bundleRoot stringByAppendingPathComponent:@"DragCommands"];
	NSString *commandsOutputPath = [outputFile stringByAppendingPathComponent:@"dragcommands"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	if (![[NSFileManager defaultManager] fileExistsAtPath:commandsPath]) {
		return;
	}
	// create the snippet directory...
	[fm createDirectoryAtPath:commandsOutputPath
  withIntermediateDirectories:YES 
				   attributes:nil 
						error:nil];
	
	for(NSString *command in [fm contentsOfDirectoryAtPath:commandsPath error:nil]) {
		if ([[[command pathExtension] lowercaseString] isEqual:@"tmdragcommand"] || [[[command pathExtension] lowercaseString] isEqual:@"plist"]) {
			processDragCommand([commandsPath stringByAppendingPathComponent:command], commandsOutputPath);
		}
	}
	
}


#pragma mark -
#pragma mark Macros
void importMacros(NSString *bundleRoot, NSString *outputFile)
{
	NSString *macrosPath = [bundleRoot stringByAppendingPathComponent:@"Macros"];
	NSString *macrosOutputPath = [outputFile stringByAppendingPathComponent:@"legacy_macro"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	if (![[NSFileManager defaultManager] fileExistsAtPath:macrosPath]) {
		return;
	}
	// create the macro directory...
	[fm createDirectoryAtPath:macrosOutputPath
  withIntermediateDirectories:YES 
				   attributes:nil 
						error:nil];
	
	
	for(NSString *macro in [fm contentsOfDirectoryAtPath:macrosPath error:nil]) {
		if ([[[macro pathExtension] lowercaseString] isEqual:@"tmmacro"] || [[[macro pathExtension] lowercaseString] isEqual:@"plist"]) {
			// copy it over
			NSString *fullMacroPath = [macrosPath stringByAppendingPathComponent:macro];
			NSString *fullMacroOutputPath = [macrosOutputPath stringByAppendingPathComponent:macro];
			[fm copyItemAtPath:fullMacroPath toPath:fullMacroOutputPath error:nil];
		}
	}
	
}



#pragma mark -
#pragma mark Commands

void processCommand(NSString *fullPath, NSString *outputPath)
{
	NSString *fileName = T2TSanatizeRepresentationIdentifier([fullPath lastPathComponent]);
	NSString *fullFileName = [fileName stringByReplacingOccurrencesOfString:[fileName pathExtension] withString:@"selfml"];
	NSDictionary *commandDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:fullPath] options:0 format:nil error:nil];
	NSString *fullOutputPath = [outputPath stringByAppendingPathComponent:fullFileName];
	SFONode *rootNode = [SFONode node];
	
	
	// output equivalent dic
	NSMutableDictionary *outputDic = [[NSMutableDictionary alloc] init];
	[outputDic setObject:@"nothing" forKey:@"discard"];
	[outputDic setObject:@"replace-selected" forKey:@"replaceSelectedText"];
	[outputDic setObject:@"replace-all" forKey:@"replaceDocument"];
	[outputDic setObject:@"after-selected" forKey:@"afterSelectedText"];
	[outputDic setObject:@"snippet" forKey:@"insertAsSnippet"];
	[outputDic setObject:@"html" forKey:@"showAsHTML"];
	[outputDic setObject:@"tooltip" forKey:@"showAsTooltip"];
	[outputDic setObject:@"new-document" forKey:@"openAsNewDocument"];
	
	// beforeRunningCommand dic
	NSMutableDictionary *brcDic = [[NSMutableDictionary alloc] init];
	[brcDic setObject:@"nothing" forKey:@"nop"];
	[brcDic setObject:@"file" forKey:@"saveActiveFile"];
	[brcDic setObject:@"project" forKey:@"saveModifiedFiles"];
	
	
	// key triggers
	SFONode *triggerNode = SELFML(@"trigger");
	if ([[commandDic objectForKey:@"keyEquivalent"] length]) {
		NSArray *keyEquivArray = T2TConvertKeyEquivalent([commandDic objectForKey:@"keyEquivalent"]);
		if (keyEquivArray)
		{
			SFONode *keyNode = SELFML(@"key", [keyEquivArray componentsJoinedByString:@""]);
			[triggerNode addChild:keyNode];
		}
	}
	if ([[commandDic objectForKey:@"tabTrigger"] length]) {
		SFONode *tabNode = SELFML(@"tab", [commandDic objectForKey:@"tabTrigger"]);
		[triggerNode addChild:tabNode];
	}
	[rootNode addChild:triggerNode];
	
	// name
	if ([[commandDic objectForKey:@"name"] length]) {
		SFONode *nameNode = SELFML(@"name", [commandDic objectForKey:@"name"]);
		[rootNode addChild:nameNode];
	}
	
	// scope
	if ([[commandDic objectForKey:@"scope"] length]) {
		SFONode *scopeNode = SELFML(@"only-in", [commandDic objectForKey:@"scope"]);
		[rootNode addChild:scopeNode];
	}
	
	// input
	if ([[commandDic objectForKey:@"input"] length] != nil) {
		NSString *inputValue = ([[commandDic objectForKey:@"input"] isEqual:@"none"]) ? @"nothing" : [commandDic objectForKey:@"input"];
		SFONode *inputNode = SELFML(@"input", inputValue);
		
		if ([[commandDic objectForKey:@"fallbackInput"] length] != nil) {
			NSString *fallbackInputValue = ([[commandDic objectForKey:@"fallbackInput"] isEqual:@"none"]) ? @"nothing" : [commandDic objectForKey:@"fallbackInput"];
			[inputNode addChild:fallbackInputValue];
		}
		
		[rootNode addChild:inputNode];
	}
	
	// output
	if ([[commandDic objectForKey:@"output"] length] != nil) {
		NSString *outputValue = [outputDic objectForKey:[commandDic objectForKey:@"output"]];
		SFONode *outputNode = SELFML(@"output", outputValue);
		[rootNode addChild:outputNode];
	}
	
	// brc
	if ([[commandDic objectForKey:@"beforeRunningCommand"] length] != nil) {
		SFONode *brcNode = SELFML(@"save", [brcDic objectForKey:[commandDic objectForKey:@"beforeRunningCommand"]]);
		[rootNode addChild:brcNode];
	}
	
	// src
	if ([[commandDic objectForKey:@"command"] length] != nil) {
		SFONode *commandNode = SELFML(@"script", [commandDic objectForKey:@"command"]);
		[rootNode addChild:commandNode];
	}
	
	[[rootNode selfmlRepresentation] writeToFile:fullOutputPath 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
}

void importCommands(NSString *bundleRoot, NSString *outputFile)
{
	NSString *commandsPath = [bundleRoot stringByAppendingPathComponent:@"Commands"];
	NSString *commandsOutputPath = [outputFile stringByAppendingPathComponent:@"commands"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	if (![[NSFileManager defaultManager] fileExistsAtPath:commandsPath]) {
		return;
	}
	// create the snippet directory...
	[fm createDirectoryAtPath:commandsOutputPath
  withIntermediateDirectories:YES 
				   attributes:nil 
						error:nil];
	
	for(NSString *command in [fm contentsOfDirectoryAtPath:commandsPath error:nil]) {
		if ([[[command pathExtension] lowercaseString] isEqual:@"tmcommand"] || [[[command pathExtension] lowercaseString] isEqual:@"plist"]) {
			processCommand([commandsPath stringByAppendingPathComponent:command], commandsOutputPath);
		}
	}
	
}


#pragma mark -
#pragma mark Language/Syntax

void processPattern(NSDictionary *pattern, SFONode **rootNode) {
	SFONode *nodePattern;
	
	// Deal with includes right alway
	if ([pattern objectForKey:@"include"] != nil) {
		nodePattern = SELFML(@"include", [[pattern objectForKey:@"include"] stringByReplacingOccurrencesOfString:@"#" withString:@"@"]);
		[*rootNode addChild:nodePattern];
		return;
	}
	
	
	if ([pattern objectForKey:@"name"] != nil) {
		nodePattern = SELFML(@"zone", [pattern objectForKey:@"name"]);
	} else {
		nodePattern = SELFML(@"zone");
		if ([pattern objectForKey:@"contentName"] != nil) {
			SFONode *innerIdentifier = SELFML(@"inner-identifier", [pattern objectForKey:@"contentName"]);
			[nodePattern addChild:innerIdentifier];
		}
	}
	
	
	// match
	if ([pattern objectForKey:@"match"] != nil) {
		SFONode *matchNode = SELFML(@"match");
		SFONode *regexNode = processRegex([pattern objectForKey:@"match"], &matchNode, [[pattern objectForKey:@"captures"] count] == 0);
		
		
		//[matchNode addChild:regexNode];
		
		if ([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *captureDic = [pattern objectForKey:@"captures"];
			
			if ([captureDic objectForKey:@"contentName"] != nil){
				[matchNode addChild:(NSString *)[captureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [captureDic allKeys]) {
				if ([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML([akey description], [[captureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		[nodePattern addChild:matchNode];
	}
	if ([pattern objectForKey:@"begin"] != nil) {
		SFONode *startNode = SELFML(@"start");
		SFONode *regexNode = processRegex([pattern objectForKey:@"begin"], &startNode, [pattern objectForKey:@"beginCaptures"] == nil && [pattern objectForKey:@"captures"] == nil);
		
		if ([pattern objectForKey:@"beginCaptures"] != nil) {
			NSDictionary *beginCaptureDic = [pattern objectForKey:@"beginCaptures"];
			
			if ([beginCaptureDic objectForKey:@"contentName"] != nil){
				[startNode addChild:(NSString *)[beginCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [beginCaptureDic allKeys]) {
				if ([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[beginCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		// is there a captures node?
		if ([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *weirdCaptureDic = [pattern objectForKey:@"captures"];
			
			for(NSString *akey in [weirdCaptureDic allKeys]) {
				if ([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *weirdCaptureNode = SELFML(akey, [[weirdCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:weirdCaptureNode];
				}
			}
		}
		
		[nodePattern addChild:startNode];
	}
	if ([pattern objectForKey:@"end"] != nil) {
		SFONode *endNode = SELFML(@"end");
		SFONode *regexNode = processRegex([pattern objectForKey:@"end"], &endNode, [pattern objectForKey:@"endCaptures"] == nil && [pattern objectForKey:@"captures"] == nil);
		
		if ([pattern objectForKey:@"endCaptures"] != nil) {
			NSDictionary *endCaptureDic = [pattern objectForKey:@"endCaptures"];
			
			if ([endCaptureDic objectForKey:@"contentName"] != nil){
				[endNode addChild:(NSString *)[endCaptureDic objectForKey:@"contentName"]];
			} 			
			for(NSString *akey in [endCaptureDic allKeys]) {
				if ([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *captureNode = SELFML(akey, [[endCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:captureNode];
				}
			}
		}
		
		
		// is there a captures node?
		if ([pattern objectForKey:@"captures"] != nil) {
			NSDictionary *weirdEndCaptureDic = [pattern objectForKey:@"captures"];
			
			for(NSString *akey in [weirdEndCaptureDic allKeys]) {
				if ([akey intValue] || [akey isEqual:@"0"] || [akey isEqual:[NSNumber numberWithInt:0]]) {
					SFONode *weirdEndCaptureNode = SELFML(akey, [[weirdEndCaptureDic valueForKey:akey] valueForKey:@"name"]);
					[regexNode addChild:weirdEndCaptureNode];
				}
			}
		}
		
		
		[nodePattern addChild:endNode];
	}
	
	// Deal with inner patterns...reccursively?
	if ([pattern objectForKey:@"patterns"] != nil) {
		SFONode *subzoneNode = SELFML(@"subzones");
		for(NSDictionary *subpattern in [pattern valueForKey:@"patterns"]) {
			processPattern(subpattern, &subzoneNode);
		}
		[nodePattern addChild:subzoneNode];
	}
	
	[*rootNode addChild:nodePattern];
}

void processLanguage(NSString *bundleRoot, NSString *languagePath, NSString *outputPath)
{
	NSDictionary *languageAsDic = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:languagePath] options:0 format:nil error:nil];
	NSString *bundleSourceName = [languageAsDic objectForKey:@"name"];
	if (![bundleSourceName length])
		bundleSourceName = [[languagePath lastPathComponent] stringByDeletingPathExtension];
	
	NSString *outputDirName = bundleSourceName;
	
	// Create the output directory
	[[NSFileManager defaultManager] createDirectoryAtPath:[outputPath stringByAppendingPathComponent:outputDirName]
							  withIntermediateDirectories:NO 
											   attributes:nil 
													error:nil];
	
	NSString *rootScope = [languageAsDic valueForKey:@"scopeName"];
	if (![rootScope length])
		return;
	
	SFONode *rootNode = SELFML(@"root", rootScope);
	SFONode *ubberRootNode = [SFONode node];
	
	// patterns...
	for(NSDictionary *pattern in [languageAsDic valueForKey:@"patterns"])
	{
		processPattern(pattern, &rootNode);
	}
	
	[ubberRootNode addChild:rootNode];
	// collections/repo
	for(NSString *repoKey in [languageAsDic objectForKey:@"repository"]) {
		SFONode *collectionNode = SELFML(@"collection", repoKey);
		NSDictionary *collectionDic = [[languageAsDic objectForKey:@"repository"] objectForKey:repoKey];
		// is it the dumb exception?
		if ([[collectionDic allKeys] count] == 1 && [collectionDic objectForKey:@"patterns"] != nil) {
			// yes it is!
			for(NSDictionary *subzone in [collectionDic objectForKey:@"patterns"]) {
				processPattern(subzone, &collectionNode);
			}
		} else {
			processPattern(collectionDic, &collectionNode);
		}
		
		
		[ubberRootNode addChild:collectionNode];
	}
	
	
	[[ubberRootNode selfmlRepresentation] writeToFile:[[outputPath stringByAppendingPathComponent:outputDirName] stringByAppendingPathComponent:@"syntax.selfml"] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
	
	processIq(bundleRoot, [outputPath stringByAppendingPathComponent:outputDirName], rootScope, languageAsDic);
}

void importLanguages(NSString *bundleRoot, NSString *outputFile)
{
	NSString *syntaxInPath = [bundleRoot stringByAppendingPathComponent:@"Syntaxes"];
	NSString *syntaxOutPath = [outputFile stringByAppendingPathComponent:@"languages"];
	
	
	// create the languages directory...
	[[NSFileManager defaultManager] createDirectoryAtPath:syntaxOutPath
							  withIntermediateDirectories:YES 
											   attributes:nil 
													error:nil];
	
	for(NSString *language in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:syntaxInPath error:nil]) {
		if ([[[language pathExtension] lowercaseString] isEqual:@"tmlanguage"] || [[[language pathExtension] lowercaseString] isEqual:@"plist"]) {
			processLanguage(bundleRoot, [syntaxInPath stringByAppendingPathComponent:language], syntaxOutPath);
		}
	}
	
}

#pragma mark -
#pragma mark Resources

void copyResources(NSString *bundleRoot, NSString *outputFile)
{
	NSString *supportDir = [bundleRoot stringByAppendingPathComponent:@"Support"];
	NSString *destinationPath = [outputFile stringByAppendingPathComponent:@"resources"];
	
	if (![[NSFileManager defaultManager] fileExistsAtPath:supportDir]) 
		return;
	
	
	[[NSFileManager defaultManager] copyItemAtPath:supportDir toPath:destinationPath error:nil];
	
	
}

#pragma mark -
#pragma mark Templates
void processTemplateFile(NSString *fullPath, SFONode **rootNode, BOOL isPrimary) 
{
	NSString *fileName = [fullPath lastPathComponent];
	NSString *displayName = [fileName stringByDeletingPathExtension];
	NSString *fileContent = [NSString stringWithContentsOfFile:fullPath encoding:NSUTF8StringEncoding error:nil];
	NSString *convertedContent = T2TConvertTextMateSnippetToChocolat(fileContent);
	SFONode *fileNode;
	if (isPrimary) {
		fileNode = SELFML(@"file.primary");
	} else {
		fileNode = SELFML(@"file");
	}
	//name
	SFONode *nameNode = SELFML(@"name", displayName);
	[fileNode addChild:nameNode];
	
	//file name
	SFONode *filenameNode = SELFML(@"filename", fileName);
	[fileNode addChild:filenameNode];
	
	//content
	SFONode *contentNode = SELFML(@"contents", convertedContent);
	[fileNode addChild:contentNode];
	
	
	[*rootNode addChild:fileNode];
}


void processTemplate(NSString *fullPath, NSString *outputDir, NSString *bundleRoot)
{
	// OK so, the info.plist contains the meta data about the template,
	// every other file in there is an actual template!
	SFONode *rootNode = [SFONode node];
	NSDictionary *metaData = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[fullPath stringByAppendingPathComponent:@"info.plist"]]
																	   options:0 
																		format:nil 
																		 error:nil];
	
	NSDictionary *bundleMetaData = [NSPropertyListSerialization propertyListWithData:[NSData dataWithContentsOfFile:[bundleRoot stringByAppendingPathComponent:@"info.plist"]]
																			 options:0 
																			  format:nil 
																			   error:nil];
	
	NSString *fileName;
	// first the name!
	if ([metaData objectForKey:@"name"]) {
		SFONode *nameNode = SELFML(@"name", [metaData valueForKey:@"name"]);
		[rootNode addChild:nameNode];
		fileName = [[metaData valueForKey:@"name"] stringByAppendingString:@".selfml"];
	} else {
		return;
	}
	// a key equiv? fuuuu
	if ([metaData objectForKey:@"keyEquivalent"] != nil) {
		SFONode *triggerNode = SELFML(@"trigger");
		NSArray *keyEquivArray = T2TConvertKeyEquivalent([metaData objectForKey:@"keyEquivalent"]);
		SFONode *keyNode = SELFML(@"key", [keyEquivArray componentsJoinedByString:@""]);
		[triggerNode addChild:keyNode];
		[rootNode addChild:triggerNode];
	}
	
	
	// Group
	SFONode *platformNode = SELFML(@"group.platform", @"Misc");
	[rootNode addChild:platformNode];
	
	// Get the name of the bundle...
	SFONode *principleNode;
	if ([bundleMetaData objectForKey:@"name"] != nil) {
		principleNode = SELFML(@"group.principles", [bundleMetaData objectForKey:@"name"]);
	} else {
		principleNode = SELFML(@"group.principles", @"Unknown");
	}
	[rootNode addChild:principleNode];
	
	// now process the template files...
	int i = 0;
	BOOL primary;
	for(NSString *aFile in [[NSFileManager defaultManager] contentsOfDirectoryAtPath:fullPath error:nil]) {
		if (![[aFile lowercaseString] isEqual:@"info.plist"]) {
			processTemplateFile([fullPath stringByAppendingPathComponent:aFile], &rootNode, (i == 0) );
			i++;
		}
	}
	
	
	[[rootNode selfmlRepresentation] writeToFile:[outputDir stringByAppendingPathComponent:fileName] 
									  atomically:YES 
										encoding:NSUTF8StringEncoding 
										   error:nil];
	
}

void importTemplates(NSString *bundleRoot, NSString *outputFile)
{
	NSString *templatePath = [bundleRoot stringByAppendingPathComponent:@"Templates"];
	NSString *templateOutputDir = [outputFile stringByAppendingPathComponent:@"templates"];
	NSFileManager *fm = [NSFileManager defaultManager];
	
	// do we have to import them?
	if (![fm fileExistsAtPath:templatePath]) {
		return;
	}
	// create the template output dir...
	[fm createDirectoryAtPath:templateOutputDir attributes:nil];
	
	// Get the full path and process it!
	for(NSString *templateDir in [fm contentsOfDirectoryAtPath:templatePath error:nil]) {
		processTemplate([templatePath stringByAppendingPathComponent:templateDir], templateOutputDir, bundleRoot);
	}
	
}



